function [fval_vec,strys,strexo] = FindK(x,strys,strexo,strpar)
    % function [fval_vec,strys] = FindK(x,strys,strexo,strpar)
    % finds capital stock vector to fulfill the static equations of the 
    % model
    % Inputs: 
    %   - x         [vector]     vector of initial values for the steady
    %                            state of the regional and sectoral capital
    %                            stock
    %   - strys     [structure]  structure containing all endogeonous 
    %                            variables of the model
    %   - strexo    [structure]  structure containing all exogeonous 
    %                            variables of the model    
    %   - strpar    [structure]  structure containing all parameters of the
    %                            model
    %
    % Output: 
    %   - fval_vec  [vector]     residuals of regional and sector specific
    %                            for FOC of Households with respect to 
    %                            regional labour
    %   - strys     [structure]  see inputs
    %   - strexo    [structure]  see inputs
    % Structure: 
    %   I) Assign starting values to the endogenous variables you want to
    %   find.
    %   II) 
    %                            state of the regional and sectoral capital
    %                            stock
    %   - strys     [structure]  structure containing all endogeonous 
    %                            variables of the model
    %   - strexo    [structure]  structure containing all exogeonous 
    %                            variables of the model    
    %   - strpar    [structure]  structure containing all parameters of the
    %                            model
    %
    % Output: 
    %   - fval_vec  [vector]     residuals of regional and sector specific
    %                            for FOC of Households with respect to 
    %                            regional labour
    %   - strys     [structure]  see inputs
    %   - strexo    [structure]  see inputs


    % assign predetermined variables 
    [strys, strpar, strexo] = AssignPredeterminedVariables(strys, strpar, strexo);
    
    
    % get maximum number of eectors
    strpar.sMaxsec = num2str(strpar.inbsectors_p);
    strys.s = 1;
    % get guesses for the capital stock
    istart = 1;
    
    iend = strpar.(['subend_' strpar.sMaxsec '_p'])*strpar.inbregions_p;
    
    x_start_vec_1 = real(sqrt(x(istart:iend).^2));
    if strpar.lCalibration_p ~= 2    
        % get guesses for intermediate production
        istart = iend+1;
    
        iend   = iend + (strpar.(['subend_' strpar.sMaxsec '_p'])*strpar.inbregions_p);
    
        x_start_vec_2 = x(istart:iend);
    end
    % get guesses for exports
    istart = iend+1;
    
    iend   = iend+strpar.(['subend_' strpar.sMaxsec '_p'])*strpar.inbregions_p;
    
    x_start_vec_3 = real(sqrt(x(istart:iend).^2));
    
    % get guess for prices 
    istart = iend+1;
    
    iend   = iend+strpar.inbregions_p*strpar.(['subend_' strpar.sMaxsec '_p']);    

    x_start_vec_4 = real(sqrt(x(istart:iend).^2));
    
    % get guess for total imports
    istart = iend+1;
    
    iend   = iend+strpar.inbregions_p;
    
    x_start_vec_5 = x(istart:iend);

    if strpar.lCalibration_p == 2
        % terminal labour supply
        strys.N = strpar.NT_p;

        % terminal GDP
        strys.Y = strpar.YT_p;
    end
    for icoreg = 1:strpar.inbregions_p
        sreg = num2str(icoreg);
        if strpar.lCalibration_p == 2
            strys.(['Q_U_' sreg]) = x_start_vec_5(icoreg)*strys.Y;
        else
            strys.(['Q_U_' sreg]) = x_start_vec_5(icoreg);
        end
        
    end

    istart = iend+1;
    
    iend   = iend+strpar.inbregions_p;
    
    % get guess for fossil energy share
    x_start_vec_6 = x(istart:iend);

    for icoreg = 1:strpar.inbregions_p
        sreg = num2str(icoreg);       
        strys.(['sF_' sreg]) = x_start_vec_6(icoreg);
        
    end




    if any(strys.lEndoQvec(:)==0)
        istart = iend+1;
        iend   = iend+sum(strys.lEndoQvec(:)==0);
        x_start_vec_8 = x(istart:iend); 
        icomatch = 0;
        for icosec = 1:strpar.inbsectors_p
            ssec = num2str(icosec);
            for icosubsec = strpar.(['substart_' ssec '_p']):strpar.(['subend_' ssec '_p'])
                ssubsec = num2str(icosubsec);
                for icoreg = 1:strpar.inbregions_p
                    sreg = num2str(icoreg);
                    if strpar.(['lEndoQ_' ssubsec '_' sreg '_p']) == 0
                        icomatch = icomatch + 1;
                        strys.(['A_' ssubsec '_' sreg]) = x_start_vec_8(icomatch); %# ok
                    end
                end
            end
        end
    end

    if any(strys.lEndoQIvec(:))
        istart = iend+1;
        iend   = iend+sum(strys.lEndoQIvec);
        x_start_vec_9 = x(istart:iend); 
        icomatch = 0;
        for icosec = 1:strpar.inbsectors_p
            ssec = num2str(icosec);
            for icosubsec = strpar.(['substart_' ssec '_p']):strpar.(['subend_' ssec '_p'])
                ssubsec = num2str(icosubsec);
                for icoreg = 1:strpar.inbregions_p
                    sreg = num2str(icoreg);
                    icovec = icoreg + (icosubsec-1)*strpar.inbregions_p;     
                    if strys.lEndoQIvec(icovec)
                        icomatch = icomatch + 1;
                        strys.(['A_I_' ssubsec '_' sreg]) = x_start_vec_9(icomatch); %# ok
                    end
                end
            end
        end
    end
    
    
   if strpar.lEndoMig_p == 1
        istart = iend+1;
        iend   = iend+strpar.inbregions_p;
        x_start_vec_10 = x(istart:iend); 
        for icoreg = 1:strpar.inbregions_p
            sreg = num2str(icoreg);
            strys.(['LF_' sreg]) = x_start_vec_10(icoreg);
        end
   end
    
    if strpar.phiG_p > 0
        istart = iend+1;
        iend = iend+strpar.inbregions_p;
        x_start_vec_G = x(istart:iend);
        for icoreg = 1:strpar.inbregions_p
            sreg = num2str(icoreg);
            strys.(['G_' sreg]) = x_start_vec_G(icoreg);
        end
    end


    if strexo.exo_CapTradeInternat == 1 && strpar.lEndogenousY_p == 1
        istart = iend+1;
        iend = istart;
        strys.PE = real(sqrt(x(istart).^2));
    else
        for icoreg = 1:strpar.inbregions_p
            sreg = num2str(icoreg);
            if strexo.(['exo_CapTrade_' sreg]) == 1 && strpar.lEndogenousY_p == 1
                istart = iend+1;
                iend = istart;
                strys.(['PE_' sreg]) = real(sqrt(x(istart).^2));
            end
        end
    end


    for icoreg = 1:strpar.inbregions_p
        sreg = num2str(icoreg);
        if strexo.(['exo_tauSTr_' sreg]) > 0
            istart = iend+1;
            iend = istart;
            strys.(['Tr_' sreg]) = real(sqrt(x(istart).^2));
        end
    end

    for icoreg = 1:strpar.inbregions_p
        sreg = num2str(icoreg);
        if strexo.(['exo_tauS_' sreg]) > 0
            istart = iend+1;
            iend = istart;
            strys.(['tauS_' sreg]) = real(sqrt(x(istart).^2));
        end
    end


    if strpar.iSecHouse_p ~= 0
        for icoreg = 1:strpar.inbregions_p
            sreg = num2str(icoreg);
            istart = iend+1;
            iend = istart;
            if strpar.lEndogenousY_p == 1
                strys.(['H_' sreg]) = real(sqrt(x(istart).^2));
            else
                strys.(['PH_' sreg]) = real(sqrt(x(istart).^2));
            end
        end    
    end

    % compute foreign interest rate
    strys.rf = 1/(strpar.beta_p*exp(strexo.exo_beta))-1 + strexo.exo_rf;
    
    % assign regional climate variables 
    for icoreg = 1:strpar.inbregions_p
        sreg = num2str(icoreg);      
        for sClimateVar = strpar.casClimatevarsRegional           
            strys.([char(sClimateVar) '_' sreg]) = strpar.([char(sClimateVar) '0_' sreg '_p']) + strexo.(['exo_' char(sClimateVar) '_' sreg]);
            
        end        
    end
    for sClimateVar = strpar.casClimatevarsNational
        strys.(char(sClimateVar)) = strpar.([char(sClimateVar) '0_p']) + strexo.(['exo_' char(sClimateVar)]); 
        
    end
    
    for icoreg = 1:strpar.inbregions_p
        sreg = num2str(icoreg);    
        % define regional price level
        strys.(['P_D_' sreg]) = strpar.(['P0_D_' sreg '_p']) .* exp(strexo.(['exo_P_D_' sreg]));
        % define valuation effects through exchange rates and asset price
        % fluctuations
        strys.(['s_' sreg]) = strpar.(['s0_' sreg '_p']) * exp(strexo.(['exo_s_' sreg]));
    end

    

  
    for icosec = 1:strpar.inbsectors_p
        ssec = num2str(icosec);
        for icosubsec = strpar.(['substart_' ssec '_p']):strpar.(['subend_' ssec '_p'])
            ssubsec = num2str(icosubsec);
            for icoreg = 1:strpar.inbregions_p
                sreg = num2str(icoreg);
                icovec = icoreg + strpar.inbregions_p * (icosubsec-1);
                if strpar.lCalibration_p == 2
                    % get initial guesses for export shares
                    strys.(['D_X_' ssubsec '_' sreg]) = x_start_vec_3(icovec);    

                else
                    % get initial guesses for exports
                    strys.(['X_' ssubsec '_' sreg]) = x_start_vec_3(icovec);    
                end
            end
            % compute import prices
            strys.(['P_M_' ssubsec]) = (strpar.(['P_M_' ssubsec '_p'])+ strexo.(['exo_M_' ssubsec]));        
        end
    end 
    
    % get price levels for production and compute regional price level of
    % production for exports.
    strys.(['P_Q_' sreg]) = 0;
    for icosec = 1:strpar.inbsectors_p
        ssec = num2str(icosec);
        for icosubsec = strpar.(['substart_' ssec '_p']):strpar.(['subend_' ssec '_p'])
            ssubsec = num2str(icosubsec);
            for icoreg = 1:strpar.inbregions_p
                sreg = num2str(icoreg);
                icovec = icoreg + (icosubsec-1)*strpar.inbregions_p;
                strys.(['P_Q_' ssubsec '_' sreg]) = sqrt(real(x_start_vec_4(icovec)).^2);
                strys.(['P_Q_' sreg]) = strys.(['P_Q_' sreg]) + strpar.(['D_X_'  ssubsec '_' sreg '_p']) * strys.(['P_Q_' ssubsec '_' sreg])^(1-strpar.etaX_p);
            end
        end
    end
    strys.(['P_Q_' sreg]) = strys.(['P_Q_' sreg])^(1/(1-strpar.etaX_p));    
    
    
    for icoreg = 1:strpar.inbregions_p
        sreg = num2str(icoreg);
        if strpar.etaM_p == 1
            % aggregate sector production
            strys.(['P_F_' sreg])  = 1;
        else
            % aggregate sector production
            strys.(['P_F_' sreg])  = 0;            
        end        
        
        
        for icosec = 1:strpar.inbsectors_p
            ssec = num2str(icosec); 
            if strpar.(['etaQA_' ssec '_p']) == 1
                % aggregate sector production
                strys.(['P_A_' ssec '_' sreg])  = 1;
                % import prices
                strys.(['P_M_A_' ssec '_' sreg])  = 1;
            else
                % aggregate sector production
                strys.(['P_A_' ssec '_' sreg])  = 0;                            
                
                % import prices
                strys.(['P_M_A_' ssec '_' sreg])  = 0;            
            end
            for icosubsec = strpar.(['substart_' ssec '_p']):strpar.(['subend_' ssec '_p'])
                ssubsec = num2str(icosubsec);               
                
                if strpar.(['etaQ_' ssubsec '_p']) == 1
                    strys.(['P_D_' ssubsec '_' sreg]) = 1;
                else
                    strys.(['P_D_' ssubsec '_' sreg]) = 0;                        
                end
                for icoregm = 1:strpar.inbregions_p
                    sregm = num2str(icoregm); 
                    if strpar.(['etaQ_' ssubsec '_p']) == 1
                        strys.(['P_D_' ssubsec '_' sreg]) = strys.(['P_D_' ssubsec '_' sreg]) * (strys.(['P_Q_' ssubsec '_' sregm])/strpar.(['omegaQ_' ssubsec '_' sreg '_' sregm '_p']))^strpar.(['omegaQ_' ssubsec '_' sreg '_' sregm '_p']);
                    else
                        strys.(['P_D_' ssubsec '_' sreg]) = strys.(['P_D_' ssubsec '_' sreg]) + strpar.(['omegaQ_' ssubsec '_' sreg '_' sregm '_p']) * (strys.(['P_Q_' ssubsec '_' sregm]))^(1 - strpar.(['etaQ_' ssubsec '_p']));                        
                    end
                end
                if strpar.(['etaQ_' ssubsec '_p']) == 1
                    strys.(['P_D_' ssubsec '_' sreg]) = strys.(['P_D_' ssubsec '_' sreg]) * (strys.(['P_M_' ssubsec])/strpar.(['omegaM_' ssubsec '_' sreg '_p']))^strpar.(['omegaM_' ssubsec '_' sreg '_p']);
                else
                    strys.(['P_D_' ssubsec '_' sreg]) = strys.(['P_D_' ssubsec '_' sreg]) + strpar.(['omegaM_' ssubsec '_' sreg '_p']) * (strys.(['P_M_' ssubsec]))^(1 - strpar.(['etaQ_' ssubsec '_p']));                        
                    strys.(['P_D_' ssubsec '_' sreg]) = strys.(['P_D_' ssubsec '_' sreg])^(1 / (1 - strpar.(['etaQ_' ssubsec '_p'])));                        
                end


                if strpar.(['etaQA_' ssec '_p']) == 1
                    strys.(['P_A_' ssec '_' sreg]) = strys.(['P_A_' ssec '_' sreg]) * (strys.(['P_D_' ssubsec '_' sreg])/strpar.(['omegaQ_' ssubsec '_' sreg '_p']))^strpar.(['omegaQ_' ssubsec '_' sreg '_p']);
                    strys.(['P_M_A_' ssec '_' sreg]) = strys.(['P_M_A_' ssec '_' sreg]) * (strys.(['P_M_' ssubsec])/strpar.(['omegaQ_' ssubsec '_' sreg '_p']))^strpar.(['omegaQ_' ssubsec '_' sreg '_p']);
                    
                else
                    strys.(['P_A_' ssec '_' sreg]) = strys.(['P_A_' ssec '_' sreg]) + strpar.(['omegaQ_' ssubsec '_' sreg '_p']) * (strys.(['P_D_' ssubsec '_' sreg]))^(1 - strpar.(['etaQA_' ssec '_p']));                        
                    strys.(['P_M_A_' ssec '_' sreg]) = strys.(['P_M_A_' ssec '_' sreg]) + strpar.(['omegaM_F_' ssubsec '_' sreg '_p']) * (strys.(['P_M_' ssubsec]))^(1 - strpar.(['etaQA_' ssec '_p']));                        
                end                    


            end
            if strpar.(['etaQA_' ssec '_p']) ~= 1
                % aggregate sector production
                strys.(['P_A_' ssec '_' sreg])  = strys.(['P_A_' ssec '_' sreg])^(1/(1 - strpar.(['etaQA_' ssec '_p'])));
                strys.(['P_M_A_' ssec '_' sreg])  = strys.(['P_M_A_' ssec '_' sreg])^(1/(1 - strpar.(['etaQA_' ssec '_p'])));
            end         
            
            if strpar.etaQ_p == 1
                strys.(['P_F_' sreg]) = strys.(['P_F_' sreg]) * (strys.(['P_M_A_' ssec '_' sreg])/strpar.(['omegaMA_F_' ssec '_' sreg '_p']))^strpar.(['omegaMA_F_' ssec '_' sreg '_p']);
            else
                strys.(['P_F_' sreg]) = strys.(['P_F_' sreg]) + strpar.(['omegaMA_F_' ssec '_' sreg '_p']) * (strys.(['P_M_A_' ssec '_' sreg]))^(1 - strpar.etaQ_p);                        
            end             
        end

        if strpar.etaQ_p ~= 1
            % aggregate sector production
            strys.(['P_F_' sreg])  = strys.(['P_F_' sreg])^(1/(1 - strpar.etaQ_p));
        end

        if strpar.etaF_p ~= 1
            % aggregate sector production
            strys.(['P_' sreg])  = (strpar.(['omegaF_' sreg '_p']) * strys.(['P_F_' sreg])^(1 - strpar.etaF_p) + ...
                (1 - strpar.(['omegaF_' sreg '_p'])) * strys.(['P_D_' sreg])^(1 - strpar.etaF_p))^(1/(1 - strpar.etaF_p));
        else
            strys.(['P_' sreg])  = ((strys.(['P_F_' sreg])/strpar.(['omegaF_' sreg '_p']))^(strpar.(['omegaF_' sreg '_p'])) * ...
             (strys.(['P_D_' sreg])/(1 - strpar.(['omegaF_' sreg '_p'])))^(1 - strpar.(['omegaF_' sreg '_p'])));
        end
    end 
    
    for icoreg = 1:strpar.inbregions_p
        sreg = num2str(icoreg);
        % compute final imports 
        strys.(['M_F_' sreg]) = (strys.(['P_F_' sreg]) / strys.(['P_D_' sreg]))^(-strpar.etaF_p) * strpar.(['omegaF_' sreg '_p']) / (1 - strpar.(['omegaF_' sreg '_p'])) * strys.(['Q_U_' sreg]);
        for icosec = 1:strpar.inbsectors_p
            ssec = num2str(icosec); 
            for icosubsec = strpar.(['substart_' ssec '_p']):strpar.(['subend_' ssec '_p'])
                ssubsec = num2str(icosubsec);
                
                if strpar.(['etaIA_' ssubsec '_p']) == 1
                    strys.(['P_I_' ssubsec '_' sreg]) = 1;
                else
                    strys.(['P_I_' ssubsec '_' sreg]) = 0;                        
                end
                for icosecm = 1:strpar.inbsectors_p
                    ssecm = num2str(icosecm); 
                    PAgrosstemp = strys.(['P_A_' ssecm '_' sreg]) + strpar.(['kappaEI_' ssubsec '_' sreg '_' ssecm '_p']) * strys.(['sF_' sreg]) * exp(strexo.(['exo_EI_' ssubsec '_' sreg '_' ssecm])) * strpar.(['lEndoQ_' ssubsec '_' sreg '_p']) * strys.(['PE_' sreg]);                                            
                    if strpar.(['etaIA_' ssubsec '_p']) == 1
                        strys.(['P_I_' ssubsec '_' sreg]) = strys.(['P_I_' ssubsec '_' sreg]) * (PAgrosstemp/strpar.(['omegaQI_' ssubsec '_' sreg '_' ssecm '_p']))^strpar.(['omegaQI_' ssubsec '_' sreg '_' ssecm '_p']);
                    else
                        strys.(['P_I_' ssubsec '_' sreg]) = strys.(['P_I_' ssubsec '_' sreg]) + strpar.(['omegaQI_' ssubsec '_' sreg '_' ssecm '_p']) * (PAgrosstemp)^(1 - strpar.(['etaIA_' ssubsec '_p']));                        
                    end
                end
                if strpar.(['etaIA_' ssubsec '_p']) ~= 1
                    strys.(['P_I_' ssubsec '_' sreg]) = strys.(['P_I_' ssubsec '_' sreg])^(1 / (1 - strpar.(['etaIA_' ssubsec '_p'])));                        
                end     
            end
        end
    end
    
    
    
    
    if strpar.lCalibration_p == 2    
        % [strys, strpar, strexo] = Initialize_FindK_ExogenousY(strys, strpar, strexo, x, x_start_vec_1, x_start_vec_2, x_start_vec_4);
        [strys, strpar, strexo] = Initialize_FindK_ExogenousY(strys, strpar, strexo, x, x_start_vec_1, [], x_start_vec_4);
    else
        for icosec = 1:strpar.inbsectors_p
            ssec = num2str(icosec);
            for icosubsec = strpar.(['substart_' ssec '_p']):strpar.(['subend_' ssec '_p'])
                ssubsec = num2str(icosubsec);
                for icoreg = 1:strpar.inbregions_p
                    sreg = num2str(icoreg);
                    icovec = icoreg + (icosubsec-1)*strpar.inbregions_p;

                    strys.(['K_' ssubsec '_' sreg]) = sqrt(real(x_start_vec_1(icovec)).^2);                    
                    strys.(['A_I_' ssubsec '_' sreg]) = exp(strexo.(['exo_A_I_' ssubsec '_' sreg]));
                    strys.(['Q_I_' ssubsec '_' sreg]) = sqrt(real(x_start_vec_2(icovec)).^2);
                    
                end
            end
        end
        if strpar.phiG_p > 0
            if strpar.lEndogenousY_p == 0

                strys.G = x(end-1);
            else
                
                strys.G = x(end);
            end
        end
    end
    
    % public capital stock
    strys.KG = strys.G / strpar.deltaKG_p;
    
    
    %% calculate exogenous variables
    % population stock
    for icoreg = 1:strpar.inbregions_p
        sreg = num2str(icoreg);            
        if strpar.lEndogenousY_p == 0
            % housing area
            strys.(['H_' sreg]) = (strpar.(['H0_' sreg '_p']) + strexo.(['exo_H_' sreg])) * strys.(['PoP_' sreg]);

        else
            % price per housing area
            strys.(['PH_' sreg]) = (strpar.(['PH0_' sreg '_p']) * exp(strexo.(['exo_H_' sreg])));
        end
    end
    % government expenditure to the housing area
    strys.G_A_DH = strexo.exo_G_A_DH * strpar.Q0_p;
    
    
    %% calculate sectoral and regional production factors and output
    for icosec = 1:strpar.inbsectors_p
        ssec = num2str(icosec);      
        for icoreg = 1:strpar.inbregions_p
            sreg = num2str(icoreg);           
            
            
            for icosubsec = strpar.(['substart_' ssec '_p']):strpar.(['subend_' ssec '_p'])
                ssubsec = num2str(icosubsec);       
            
                % subsectoral interat rate
                strys.(['r_' ssubsec '_' sreg]) = (1/(strpar.beta_p * exp(strexo.exo_beta)) - 1 + strpar.delta_p)/(1 - strys.(['tauKH_' sreg]));                    
                rkgross = strys.(['r_' ssubsec '_' sreg]) * (1 + strys.(['tauKF_' ssubsec '_' sreg]));

                
                % auxiliary variable to define the degree of substitutability
                % between capital and labour in the sector
                rhotemp = ((strpar.(['etaNK_' ssubsec '_' sreg '_p'])-1)/strpar.(['etaNK_' ssubsec '_' sreg '_p']));

                
                if strpar.lEndogenousY_p == 1
                    % compute regional and sub-sectoral productivity 
                    if strpar.(['lEndoQ_' ssubsec '_' sreg '_p']) == 1
                        strys.(['A_' ssubsec '_' sreg]) = strpar.(['A_' ssubsec '_' sreg '_p']) * exp(strexo.(['exo_' ssubsec '_' sreg])) * strys.KG^strpar.phiG_p;
                    end
                end
                
                if strpar.lEndogenousY_p == 1
                    % compute regional and sub-sectoral labour productivity 
                    strys.(['A_N_' ssubsec '_' sreg]) = strpar.(['A_N_' ssubsec '_' sreg '_p']) * exp(strexo.(['exo_N_' ssubsec '_' sreg]));
                end
                


                if strpar.lCalibration_p == 2 % Baseline / exogenous Y
                    if strpar.(['etaNK_' ssubsec '_' sreg '_p']) ~= 1
                        % compute regional and sub-sectoral productivity 
                        strys.(['A_' ssubsec '_' sreg]) = (rkgross / (strpar.(['alphaK_' ssubsec '_' sreg '_p'])^(1/ strpar.(['etaNK_' ssubsec '_' sreg '_p'])) *  (strys.(['A_K_' ssubsec '_' sreg]) * (1 - strys.(['D_' ssubsec '_' sreg])))^rhotemp * (strys.(['K_' ssubsec '_' sreg])/strys.(['Y_' ssubsec '_' sreg]))^(-1/strpar.(['etaNK_' ssubsec '_' sreg '_p']))))^(1/rhotemp);
                                                      
                    else
                        % compute the capital stock
                        strys.(['K_' ssubsec '_' sreg]) = strpar.(['alphaK_' ssubsec '_' sreg '_p']) * strys.(['Y_' ssubsec '_' sreg]) / rkgross;
                        
                        % compute the gross wage
                        wgross = strpar.(['alphaN_' ssubsec '_' sreg '_p']) / strpar.(['alphaK_' ssubsec '_' sreg '_p']) * strys.(['K_' ssubsec '_' sreg]) / (strys.(['LF_' sreg]) * strys.(['N_' ssubsec '_' sreg])) * rkgross * strys.(['P_' ssubsec '_' sreg]);
                        
                        % compute auxiliary variable to compute
                        % productivity
                        temp = (rkgross/(strpar.(['alphaK_' ssubsec '_' sreg '_p']) * strys.(['A_K_' ssubsec '_' sreg])))^strpar.(['alphaK_' ssubsec '_' sreg '_p']) * ...
                               (wgross/(strpar.(['alphaN_' ssubsec '_' sreg '_p']) * strys.(['A_N_' ssubsec '_' sreg]) * (1 - strys.(['D_N_' ssubsec '_' sreg])))^strpar.(['alphaK_' ssubsec '_' sreg '_p']));
                        
                        % compute subsectoral and regional productivity
                        strys.(['A_' ssubsec '_' sreg]) = strys.(['P_' ssubsec '_' sreg]) / temp;                        
                        
                    end
                    
                    % recompute the exogenous disturbances to productivity
                    % should be unneccary if everything is correct
                    if strpar.lEndogenousY_p == 1                       
                        strexo.(['exo_' ssubsec '_' sreg]) = log(strys.(['A_' ssubsec '_' sreg]) / (strys.KG^strpar.phiG_p * strpar.(['A_' ssubsec '_' sreg '_p'])));                        
                        
                    else
                        strexo.(['exo_' ssubsec '_' sreg]) = log(strys.(['Y_' ssubsec '_' sreg]) .* strys.(['P_' ssubsec '_' sreg]) ./ (strpar.Y0_p .* strpar.(['phiY0_' ssubsec '_' sreg '_p'])/strpar.phiY_p));                        
                        
                    end
                    % compute exogenous labour productivity
                    if strpar.(['etaNK_' ssubsec '_' sreg '_p']) ~= 1 % CES
                        temp1 = (strys.(['K_' ssubsec '_' sreg]) * rkgross^strpar.(['etaNK_' ssubsec '_' sreg '_p']) / (strpar.(['alphaK_' ssubsec '_' sreg '_p']) * strys.(['A_K_' ssubsec '_' sreg])^(strpar.(['etaNK_' ssubsec '_' sreg '_p'])-1) * (strys.(['A_' ssubsec '_' sreg]) * (1 - strys.(['D_' ssubsec '_' sreg])))^(strpar.(['etaNK_' ssubsec '_' sreg '_p']))))^rhotemp;
                        
                        temp2 = strpar.(['alphaK_' ssubsec '_' sreg '_p'])^(1/strpar.(['etaNK_' ssubsec '_' sreg '_p'])) * strys.(['A_K_' ssubsec '_' sreg])^rhotemp * strys.(['K_' ssubsec '_' sreg])^rhotemp;
                        
                        temp = ((temp1 - temp2) / (strpar.(['alphaN_' ssubsec '_' sreg '_p'])^(1/strpar.(['etaNK_' ssubsec '_' sreg '_p'])) * (strys.(['LF_' sreg]) .* strys.(['N_' ssubsec '_' sreg]))^rhotemp))^(1/rhotemp);                                    
                        
                        strys.(['A_N_' ssubsec '_' sreg]) = temp / (1 - strys.(['D_N_' ssubsec '_' sreg]));
                        
                        if strpar.lEndogenousY_p == 1
                            strexo.(['exo_N_' ssubsec '_' sreg]) = log(strys.(['A_N_' ssubsec '_' sreg])/strpar.(['A_N_' ssubsec '_' sreg '_p']));
                        end                        
                    else % Cobb-Douglas
                        if strpar.lEndogenousY_p == 1
                            strexo.(['exo_N_' ssubsec '_' sreg]) = log(strys.(['A_N_' ssubsec '_' sreg])/strpar.(['A_N_' ssubsec '_' sreg '_p']));

                        end
                    end      
                else  % Climate Change Scenarios / endogenous Y
                    if strpar.(['etaNK_' ssubsec '_' sreg '_p']) ~= 1
                        temp1 = (strys.(['K_' ssubsec '_' sreg]) * rkgross^strpar.(['etaNK_' ssubsec '_' sreg '_p']) / (strpar.(['alphaK_' ssubsec '_' sreg '_p']) * strys.(['A_K_' ssubsec '_' sreg])^(strpar.(['etaNK_' ssubsec '_' sreg '_p'])-1) * (strys.(['A_' ssubsec '_' sreg]) * (1 - strys.(['D_' ssubsec '_' sreg])))^(strpar.(['etaNK_' ssubsec '_' sreg '_p']))))^rhotemp;
                        
                        temp2 = strpar.(['alphaK_' ssubsec '_' sreg '_p'])^(1/strpar.(['etaNK_' ssubsec '_' sreg '_p'])) * strys.(['A_K_' ssubsec '_' sreg])^rhotemp * strys.(['K_' ssubsec '_' sreg])^rhotemp;
                        
                        temp = ((temp1 - temp2) / (strpar.(['alphaN_' ssubsec '_' sreg '_p'])^(1/strpar.(['etaNK_' ssubsec '_' sreg '_p']))))^(1/rhotemp);
                        
                        if strpar.lEndogenousY_p == 1
                            % compute labour
                            strys.(['N_' ssubsec '_' sreg]) = temp / (strys.(['LF_' sreg]) * (1 - strys.(['D_N_' ssubsec '_' sreg])) * strys.(['A_N_' ssubsec '_' sreg]));                        
                            
                        else
                            % compute labour productivity
                            strys.(['A_N_' ssubsec '_' sreg]) = temp / (strys.(['LF_' sreg]) * (1 - strys.(['D_N_' ssubsec '_' sreg])) * strys.(['N_' ssubsec '_' sreg]));
                            
                        end
                    else
                        % compute labour demand
                        strys.(['N_' ssubsec '_' sreg]) = (strys.(['K_' ssubsec '_' sreg]) * rkgross / (strpar.(['alphaK_' ssubsec '_' sreg '_p']) * strys.(['A_' ssubsec '_' sreg]) *  (1 - strys.(['D_' ssubsec '_' sreg])) * (strys.(['A_K_' ssubsec '_' sreg]) * ...
                                                           strys.(['K_' ssubsec '_' sreg]))^strpar.(['alphaK_' ssubsec '_' sreg '_p'])))^(1/strpar.(['alphaN_' ssubsec '_' sreg '_p'])) / (strys.(['A_N_' ssubsec '_' sreg]) * (1 - strys.(['D_N_' ssubsec '_' sreg])) * strys.(['LF_' sreg]));
                        

                    end 
                end
                if strpar.(['etaNK_' ssubsec '_' sreg '_p']) ~= 1 % CES
                    if strpar.lEndogenousY_p == 1
                        % compute gross vlaue added
                        strys.(['Y_' ssubsec '_' sreg]) = strys.(['A_' ssubsec '_' sreg]) * (1 - strys.(['D_' ssubsec '_' sreg])) * (strpar.(['alphaK_' ssubsec '_' sreg '_p'])^(1/strpar.(['etaNK_' ssubsec '_' sreg '_p'])) * (strys.(['A_K_' ssubsec '_' sreg]) * strys.(['K_' ssubsec '_' sreg]))^rhotemp + strpar.(['alphaN_' ssubsec '_' sreg '_p'])^(1/strpar.(['etaNK_' ssubsec '_' sreg '_p'])) * (strys.(['LF_' sreg]) * strys.(['A_N_' ssubsec '_' sreg]) * (1 - strys.(['D_N_' ssubsec '_' sreg])) * strys.(['N_' ssubsec '_' sreg]))^rhotemp)^(1/rhotemp);
                        
                    else
                        % compute productivity
                        strys.(['A_' ssubsec '_' sreg]) = strys.(['Y_' ssubsec '_' sreg]) /((1 - strys.(['D_' ssubsec '_' sreg])) * (strpar.(['alphaK_' ssubsec '_' sreg '_p'])^(1/strpar.(['etaNK_' ssubsec '_' sreg '_p'])) * (strys.(['A_K_' ssubsec '_' sreg]) * strys.(['K_' ssubsec '_' sreg]))^rhotemp + strpar.(['alphaN_' ssubsec '_' sreg '_p'])^(1/strpar.(['etaNK_' ssubsec '_' sreg '_p'])) * (strys.(['LF_' sreg]) * strys.(['A_N_' ssubsec '_' sreg]) * (1 - strys.(['D_N_' ssubsec '_' sreg])) * strys.(['N_' ssubsec '_' sreg]))^rhotemp)^(1/rhotemp));
                        
                    end
                else
                    if strpar.lEndogenousY_p == 1
                        % compute gross vlaue added % Cobb Douglas
                        strys.(['Y_' ssubsec '_' sreg]) = strys.(['A_' ssubsec '_' sreg]) * (1 - strys.(['D_' ssubsec '_' sreg])) *  (strys.(['A_K_' ssubsec '_' sreg]) * strys.(['K_' ssubsec '_' sreg]))^strpar.(['alphaK_' ssubsec '_' sreg '_p']) * (strys.(['LF_' sreg]) * strys.(['A_N_' ssubsec '_' sreg]) * (1 - strys.(['D_N_' ssubsec '_' sreg])) * strys.(['N_' ssubsec '_' sreg]))^strpar.(['alphaN_' ssubsec '_' sreg '_p']);
                        
                    else
                        % compute productivity
                        strys.(['A_' ssubsec '_' sreg]) = strys.(['Y_' ssubsec '_' sreg]) / ((1 - strys.(['D_' ssubsec '_' sreg])) *  (strys.(['A_K_' ssubsec '_' sreg]) * strys.(['K_' ssubsec '_' sreg]))^strpar.(['alphaK_' ssubsec '_' sreg '_p']) * (strys.(['LF_' sreg]) * strys.(['A_N_' ssubsec '_' sreg]) * (1 - strys.(['D_N_' ssubsec '_' sreg])) * strys.(['N_' ssubsec '_' sreg]))^strpar.(['alphaN_' ssubsec '_' sreg '_p']));
                        
                    end
                end
                % compute substitutability between intermediate goods and
                % gross value added
                rhotemp = (strpar.(['etaI_' ssubsec '_p']) - 1)/strpar.(['etaI_' ssubsec '_p']);
                
                % compute outputs
                if strpar.(['etaI_' ssubsec '_p']) ~= 1
                    strys.(['Q_' ssubsec '_' sreg]) = (strpar.(['omegaQI_' ssubsec '_' sreg '_p'])^(1/strpar.(['etaI_' ssubsec '_p'])) * (strys.(['A_I_' ssubsec '_' sreg]) * strys.(['Q_I_' ssubsec '_' sreg]))^rhotemp + ...
                                                (1 - strpar.(['omegaQI_' ssubsec '_' sreg '_p']))^(1/strpar.(['etaI_' ssubsec '_p'])) * strys.(['Y_' ssubsec '_' sreg])^rhotemp)^(1/rhotemp);
                else
                    strys.(['Q_' ssubsec '_' sreg]) = strys.(['Q_I_' ssubsec '_' sreg])^strpar.(['omegaQI_' ssubsec '_' sreg '_p']) * strys.(['Y_' ssubsec '_' sreg])^(1 - strpar.(['omegaQI_' ssubsec '_' sreg '_p']));                     
                end
                
                strys.(['E_' ssubsec '_' sreg]) = strpar.(['kappaE_' ssubsec '_' sreg '_p']) * strys.(['Q_' ssubsec '_' sreg]);
                for icosecm = 1:strpar.inbsectors_p
                    ssecm = num2str(icosecm);
                    PAgrosstemp = strys.(['P_A_' ssecm '_' sreg]) + strpar.(['kappaEI_' ssubsec '_' sreg '_' ssecm '_p']) * strys.(['sF_' sreg]) * exp(strexo.(['exo_EI_' ssubsec '_' sreg '_' ssecm])) * strpar.(['lEndoQ_' ssubsec '_' sreg '_p']) * strys.(['PE_' sreg]);
                    strys.(['Q_I_' ssubsec '_' sreg '_' ssecm]) = strpar.(['omegaQI_' ssubsec '_' sreg '_' ssecm '_p']) * (PAgrosstemp/strys.(['P_I_' ssubsec '_' sreg]))^(-strpar.(['etaIA_' ssubsec '_p'])) .* strys.(['Q_I_' ssubsec '_' sreg]);                     
                    strys.(['E_I_' ssubsec '_' sreg '_' ssecm]) = strpar.(['kappaEI_' ssubsec '_' sreg '_' ssecm '_p']) * strys.(['sF_' sreg])  * exp(strexo.(['exo_EI_' ssubsec '_' sreg '_' ssecm])) * strys.(['Q_I_' ssubsec '_' sreg '_' ssecm]);
                end
                
                
                if strpar.lCalibration_p == 2                   
                    % compute exports
                    strys.(['X_' ssubsec '_' sreg]) = strys.(['Q_' ssubsec '_' sreg]) * strys.(['D_X_' ssubsec '_' sreg]);
                else
                    % compute export share
                    strys.(['D_X_' ssubsec '_' sreg]) = strys.(['X_' ssubsec '_' sreg]) / strys.(['Q_' ssubsec '_' sreg]);
                end
            end
        end
    end    
    
    
 
    
    strys.M_I = 0;
    strys.E = 0;
    strys.Tr = 0;
    for icoreg = 1:strpar.inbregions_p
        sreg = num2str(icoreg);       
        strys.(['M_I_' sreg])  = 0;
        strys.(['E_' sreg])  = 0;
        for icosec = 1:strpar.inbsectors_p
            ssec = num2str(icosec); 
            % aggregate sector production
            strys.(['Q_A_F_' ssec '_' sreg])  = strpar.(['omegaQA_' ssec '_' sreg '_p']) * (strys.(['P_A_' ssec '_' sreg])/strys.(['P_D_' sreg]))^(-strpar.etaQ_p) * strys.(['Q_U_' sreg]);
            strys.(['Q_A_I_' ssec '_' sreg])  = 0;
            for icosecm = 1:strpar.inbsectors_p
                ssecm = num2str(icosecm); 
                for icosubsec = strpar.(['substart_' ssecm '_p']):strpar.(['subend_' ssecm '_p'])
                    ssubsec = num2str(icosubsec);  
                    PAgrosstemp = strys.(['P_A_' ssec '_' sreg]) + strpar.(['kappaEI_' ssubsec '_' sreg '_' ssec '_p']) * strys.(['sF_' sreg]) * exp(strexo.(['exo_EI_' ssubsec '_' sreg '_' ssec])) * strpar.(['lEndoQ_' ssubsec '_' sreg '_p']) * strys.(['PE_' sreg]);
                    strys.(['Q_A_I_' ssec '_' sreg])  = strys.(['Q_A_I_' ssec '_' sreg]) + strys.(['Q_I_' ssubsec '_' sreg '_' ssec]) * PAgrosstemp / strys.(['P_A_' ssec '_' sreg]);
                    strys.(['E_' sreg]) = strys.(['E_' sreg])+strys.(['E_I_' ssubsec '_' sreg '_' ssec]);
                end
            end
            strys.(['Q_A_' ssec '_' sreg]) = strys.(['Q_A_I_' ssec '_' sreg]) + strys.(['Q_A_F_' ssec '_' sreg]) + (strpar.iSecHouse_p == icosec) * strys.(['IH_' sreg]) * strys.(['PH_' sreg]) / strys.(['P_A_' ssec '_' sreg]);
            for icosubsec = strpar.(['substart_' ssec '_p']):strpar.(['subend_' ssec '_p'])
                ssubsec = num2str(icosubsec); 
                strys.(['E_' sreg]) = strys.(['E_' sreg])+strys.(['E_' ssubsec '_' sreg]);
                % aggregate subsector production
                strys.(['Q_D_' ssubsec '_' sreg])  = strpar.(['omegaQ_' ssubsec '_' sreg '_p']) * (strys.(['P_D_' ssubsec '_' sreg])/strys.(['P_A_' ssec '_' sreg]))^(-strpar.(['etaQA_' ssec '_p'])) * strys.(['Q_A_' ssec '_' sreg]);
                for icoregm = 1:strpar.inbregions_p
                    sregm = num2str(icoregm);
                    % aggregate subsector production
                    strys.(['Q_D_' ssubsec '_' sreg '_' sregm])  = strpar.(['omegaQ_' ssubsec '_' sreg '_' sregm '_p']) * (strys.(['P_Q_' ssubsec '_' sregm])/strys.(['P_D_' ssubsec '_' sreg]))^(-strpar.(['etaQ_' ssubsec '_p'])) * strys.(['Q_D_' ssubsec '_' sreg]);
                end
                strys.(['M_I_' ssubsec '_' sreg])  = strpar.(['omegaM_' ssubsec '_' sreg '_p']) * (strys.(['P_M_' ssubsec])/strys.(['P_D_' ssubsec '_' sreg]))^(-strpar.(['etaQ_' ssubsec '_p'])) * strys.(['Q_D_' ssubsec '_' sreg]);
                strys.(['M_I_' sreg])  = strys.(['M_I_' sreg]) + strys.(['M_I_' ssubsec '_' sreg]) * strys.(['P_M_' ssubsec]);
            end
        end
        strys.M_I = strys.M_I + strys.(['M_I_' sreg]);
        strys.E = strys.E + strys.(['E_' sreg]);
    end
    
   
    %% calculate sectoral and regional price indices and sectoral aggregates
    for icoreg = 1:strpar.inbregions_p
        sreg = num2str(icoreg);    
        for icosec = 1:strpar.inbsectors_p
            ssec = num2str(icosec);
            for icosubsec = strpar.(['substart_' ssec '_p']):strpar.(['subend_' ssec '_p'])
                ssubsec = num2str(icosubsec); 

                rhotemp = ((strpar.(['etaNK_' ssubsec '_' sreg '_p'])-1)/strpar.(['etaNK_' ssubsec '_' sreg '_p']));
                
                % compute sub-sectoral and regional price level of primary
                % production factors
                if strpar.lCalibration_p ~=2
                    strys.(['P_' ssubsec '_' sreg]) = (1 - strpar.(['omegaQI_' ssubsec '_' sreg '_p']))^(1/strpar.(['etaI_' ssubsec '_p'])) * (strys.(['Y_' ssubsec '_' sreg]) / strys.(['Q_' ssubsec '_' sreg]))^(-1/strpar.(['etaI_' ssubsec '_p'])) * (strys.(['P_Q_' ssubsec '_' sreg])-strpar.(['kappaE_' ssubsec '_' sreg '_p'])*strpar.(['lEndoQ_' ssubsec '_' sreg '_p']) * strys.(['PE_' sreg]));
                end

                % compute sub-sectoral and regional wages
                strys.(['W_' ssubsec '_' sreg]) = strpar.(['alphaN_' ssubsec '_' sreg '_p'])^(1/strpar.(['etaNK_' ssubsec '_' sreg '_p'])) * (strys.(['A_' ssubsec '_' sreg]) * (1 - strys.(['D_' ssubsec '_' sreg])) * strys.(['A_N_' ssubsec '_' sreg]) * (1 - strys.(['D_N_' ssubsec '_' sreg])))^rhotemp * ((strys.(['N_' ssubsec '_' sreg]) * strys.(['LF_' sreg])) / strys.(['Y_' ssubsec '_' sreg]))^(-1/strpar.(['etaNK_' ssubsec '_' sreg '_p']))*strys.(['P_' ssubsec '_' sreg]) / (1 + strys.(['tauNF_' ssubsec '_' sreg]));

                % compute capital stock in the sector and region
                strys.(['KH_' ssubsec '_' sreg]) = strys.(['K_' ssubsec '_' sreg]);% * strys.(['P_' ssubsec '_' sreg]) / strys.(['P_' sreg]);                      
                
                % Lagrange multiplier for investment
                strys.(['omegaI_' ssubsec '_' sreg]) = 1;
                
                % sub-sectoral investment
                strys.(['I_' ssubsec '_' sreg]) = (strpar.delta_p * strys.(['KH_' ssubsec '_' sreg]) + strys.(['D_K_' ssubsec '_' sreg]));
            end
        end
    end
    
    % compute aggregates
    [strys, strpar, strexo] = ComputeAggregates(strys, strpar, strexo);
    
    
    % compute tax income of the government
    [strys,strpar, strexo] = TaxIncome(strys,strpar, strexo);  
   
    % products used domestically
    strys.Q_U = 0;
    
    % aggregate debt
    strys.B = 0;
    
    % aggregate used products
    strys.Q_U = 0;
       
    % initiliaze housing expenditures for aggregation
    HousingExpenditures = 0;
    
    % initiliaze housing expenditures for aggregation
    strexo.exo_DH = 0;
    
    % initiliaze imports
    strys.M = 0;

    % initiliaze consumption
    strys.C = 0;

    % initiliaze government expenditure
    strys.G = 0;
    
    strys.CapTradeRev = 0;
    for icoreg = 1:strpar.inbregions_p
        sreg = num2str(icoreg);   
        
        strys.Q_U =  strys.Q_U + strys.(['Q_U_' sreg]) * strys.(['P_D_' sreg]);
                
        % compute regional captial and labour income
        capincometaxes = 0;
        labincometaxes = 0;
        invreg = 0;
        for icosec = 1:strpar.inbsectors_p
            ssec = num2str(icosec);
            for icosubsec = strpar.(['substart_' ssec '_p']):strpar.(['subend_' ssec '_p'])
                ssubsec = num2str(icosubsec);
  
                % interest rate including taxes 
                rkgross = strys.(['r_' ssubsec '_' sreg]) * (strys.(['tauKH_' sreg]) + strys.(['tauKF_' ssubsec '_' sreg]));

                invreg = invreg  + strys.(['I_' ssubsec '_' sreg]) * strys.(['P_' ssubsec '_' sreg]);                           

                capincometaxes = capincometaxes + strys.(['K_' ssubsec '_' sreg]) * strys.(['P_' ssubsec '_' sreg]) * rkgross;
                
                labincometaxes = labincometaxes + strys.(['W_' ssubsec '_' sreg]) * strys.(['N_' ssubsec '_' sreg]) * strys.(['LF_' sreg]) * (strys.(['tauNH_' sreg]));
            end
        end
        
        strys.(['NXD_' sreg]) =0;        
        for icoregm = 1:strpar.inbregions_p
            sregm = num2str(icoregm);
            strys.(['NX_' sreg '_' sregm]) =0;

            for icosec = 1:strpar.inbsectors_p
                ssec = num2str(icosec);
                for icosubsec = strpar.(['substart_' ssec '_p']):strpar.(['subend_' ssec '_p'])
                    ssubsec = num2str(icosubsec);
                    strys.(['NX_' sreg '_' sregm]) = strys.(['NX_' sreg '_' sregm]) + (strys.(['Q_D_' ssubsec '_' sregm '_' sreg]) * strys.(['P_Q_' ssubsec '_' sreg]) - strys.(['Q_D_' ssubsec '_' sreg '_' sregm]) * strys.(['P_Q_' ssubsec '_' sregm]));
                end
            end
            strys.(['B_' sreg '_' sregm]) = -strys.(['NX_' sreg '_' sregm])/(strys.rf) - strys.(['BG_' sreg]);
            strys.(['NXD_' sreg]) = strys.(['NXD_' sreg]) + strys.(['NX_' sreg '_' sregm]);
        end
        
        strys.(['CapTradeRev_' sreg]) = 0;
         
        for icosec = 1:strpar.inbsectors_p
            ssec = num2str(icosec);
            for icosubsec = strpar.(['substart_' ssec '_p']):strpar.(['subend_' ssec '_p'])
                ssubsec = num2str(icosubsec);
                strys.(['CapTradeRev_' sreg]) = strys.(['CapTradeRev_' sreg]) + strys.(['E_' ssubsec '_' sreg]) * strys.(['PE_' sreg]) * strpar.(['lEndoQ_' ssubsec '_' sreg '_p']);
                for icosecm = 1:strpar.inbsectors_p
                    ssecm = num2str(icosecm);
                    strys.(['CapTradeRev_' sreg]) = strys.(['CapTradeRev_' sreg]) + strys.(['E_I_' ssubsec '_' sreg '_' ssecm]) * strys.(['PE_' sreg]) * strpar.(['lEndoQ_' ssubsec '_' sreg '_p']);
                end
            end
        end
        
        strys.CapTradeRev = strys.CapTradeRev + strys.(['CapTradeRev_' sreg]);
        
        strys.(['M_' sreg]) = strys.(['M_I_' sreg]) + strys.(['P_F_' sreg]) * strys.(['M_F_' sreg]);
        
        % regional nfa due to exchange rate
        strys.(['B_' sreg]) = log(strys.(['s_' sreg]))/(strpar.phiB_p * strpar.deltaB_p)*strys.(['Y_' sreg]);        
        % net exports
        strys.(['NX_' sreg]) = -strys.(['B_' sreg])*(strys.rf);
        
        % regional net exports
        strys.(['X_' sreg]) = (strys.(['NX_' sreg])+strys.(['M_' sreg]))/strys.(['P_Q_' sreg]);        
        % consumption
        tempMF = strpar.(['omegaF_' sreg '_p']) * (strys.(['P_F_' sreg])/strys.(['P_' sreg]))^(-strpar.etaF_p);
        tempnum = strys.(['Q_' sreg]) + strys.(['Tr_' sreg]) - strys.(['Q_I_' sreg]) - capincometaxes - labincometaxes - strys.(['X_' sreg]) * strys.(['P_Q_' sreg]) + strys.(['M_I_' sreg]) +  strys.(['P_F_' sreg]) * strys.(['M_F_' sreg]) - strys.(['CapTradeRev_' sreg]) - strys.(['NXD_' sreg]) - invreg - strys.(['Y_' sreg]) * strexo.(['exo_DH_' sreg]) * (1 + strys.(['tauH_' sreg]));
        
        tempCIH = (1-strpar.h_p)*strpar.(['gamma_' sreg '_p'])/...
            ((1 - strpar.(['gamma_' sreg '_p']))* (1-strpar.beta_p * exp(strexo.exo_beta) * strpar.h_p)) * strpar.deltaH_p * strpar.beta_p * exp(strexo.exo_beta) / (1-strpar.beta_p * exp(strexo.exo_beta)*(1-strpar.deltaH_p));
        tempdenom = (1 + strys.(['tauC_' sreg]))*strys.(['P_' sreg]) * (1 + tempCIH);
        strys.(['C_' sreg])  = tempnum / tempdenom ;
        
        
        for icosec = 1:strpar.inbsectors_p
            ssec = num2str(icosec);
            strys.(['M_A_F_' ssec '_' sreg]) = strpar.(['omegaMA_F_' ssec '_' sreg '_p']) * (strys.(['P_M_A_' ssec '_' sreg])/strys.(['P_F_' sreg]))^(-strpar.etaQ_p)*strys.(['M_F_' sreg]); 
            
            
            for icosubsec = strpar.(['substart_' ssec '_p']):strpar.(['subend_' ssec '_p'])
                ssubsec = num2str(icosubsec);
                strys.(['M_F_' ssubsec '_' sreg]) = strpar.(['omegaM_F_' ssubsec '_' sreg '_p']) * (strys.(['P_M_' ssubsec])/strys.(['P_M_A_' ssec '_' sreg]))^(-strpar.(['etaQA_' ssec '_p']))*strys.(['M_A_F_' ssec '_' sreg]); 
            end            
        end                
        
        
        if strpar.iSecHouse_p == 0
            if strpar.lEndogenousY_p == 0
                % house prices
                strys.(['PH_' sreg]) = (strpar.(['gamma_' sreg '_p'])/((1 - strpar.(['gamma_' sreg '_p'])) * (1-strpar.beta_p * exp(strexo.exo_beta) * strpar.h_p))  * strpar.beta_p * exp(strexo.exo_beta) / (1 - strpar.beta_p * exp(strexo.exo_beta) * (1 - strpar.deltaH_p)) * (1-strpar.h_p)*strys.(['C_' sreg]) * strys.(['P_' sreg]) * (1 + strys.(['tauC_' sreg]))) / (strys.(['H_' sreg]) * (1 + strys.(['tauH_' sreg])));    
            
            else
                % housing stock
                strys.(['H_' sreg])  = (strpar.(['gamma_' sreg '_p'])/((1 - strpar.(['gamma_' sreg '_p']))* (1-strpar.beta_p * exp(strexo.exo_beta) * strpar.h_p))  * strpar.beta_p * exp(strexo.exo_beta) / (1 - strpar.beta_p * exp(strexo.exo_beta) * (1 - strpar.deltaH_p)) * (1-strpar.h_p)*strys.(['C_' sreg]) * strys.(['P_' sreg]) * (1 + strys.(['tauC_' sreg]))) / (strys.(['PH_' sreg]) * (1 + strys.(['tauH_' sreg])));    
            
            end
        end
        % Lagrange multiplier for the evolution of the household stock
        strys.(['omegaH_' sreg]) = strys.(['PH_' sreg]) * (1 + strys.(['tauH_' sreg]));

        % damages to the housing stock
        strys.(['DH_' sreg]) = strexo.(['exo_DH_' sreg]) * strys.Y / strys.(['PH_' sreg]);

        % investments into the housing stock
        strys.(['IH_' sreg]) = strpar.deltaH_p * strys.(['H_' sreg]) + strys.(['DH_' sreg]);

        % regional government expenditure
        strys.(['G_' sreg]) = strys.(['Q_U_' sreg]) * strys.(['P_D_' sreg]) / strys.(['P_' sreg]) + strys.(['M_F_' sreg]) * strys.(['P_F_' sreg]) / strys.(['P_' sreg]) - strys.(['C_' sreg]) - strys.(['I_' sreg]) - (strpar.iSecHouse_p == 0) * strys.(['IH_' sreg]) * strys.(['PH_' sreg]) / strys.(['P_' sreg]);        

        % aggregate housing expenditures 
        HousingExpenditures = HousingExpenditures + strys.(['PH_' sreg]) * strys.(['IH_' sreg]);
        
        % Lagrange multiplier for the budget constraint
        strys.(['lambda_' sreg]) = (1-strpar.(['gamma_' sreg '_p'])) * (1-strpar.beta_p * exp(strexo.exo_beta) * strpar.h_p) * ((1-strpar.h_p)*strys.(['C_' sreg])/strys.(['PoP_' sreg]))^(-strpar.(['gamma_' sreg '_p'])) * (strys.(['H_' sreg])/strys.(['PoP_' sreg]))^strpar.(['gamma_' sreg '_p']) * (((1-strpar.h_p)*strys.(['C_' sreg])/strys.(['PoP_' sreg]))^(1-strpar.(['gamma_' sreg '_p'])) * (strys.(['H_' sreg])/strys.(['PoP_' sreg]))^strpar.(['gamma_' sreg '_p']))^(-strpar.sigmaC_p) / (strys.(['P_' sreg]) * (1 + strys.(['tauC_' sreg])));
  
        strexo.exo_DH = strexo.exo_DH + strexo.(['exo_DH_' sreg]);
        
               
        % foreign debt / (B > 0 debitor vs. B < 0 creditor)
        strys.(['B_' sreg]) = -strys.(['NX_' sreg])/(strys.rf) - strys.(['BG_' sreg]);
        
        % net foreign asset position
        strys.B = strys.B + strys.(['B_' sreg]);
        
        % imports
        strys.M = strys.M + strys.(['M_' sreg]);

        % transfers
        strys.Tr = strys.Tr + strys.(['Tr_' sreg]);

        % consumption
        strys.C = strys.C + strys.(['P_' sreg]) * strys.(['C_' sreg]);
        


    end
    
    % compute aggregates
    [strys, strpar, strexo] = ComputeAggregates(strys, strpar, strexo);    
    
    % net exports
    strys.NX = (strys.X - strys.M);
    % compute aggregates
    
    %% government budget constraint
    fval_vec_G = nan(strpar.inbregions_p,1);
    for icoreg = 1:strpar.inbregions_p
        sreg = num2str(icoreg);
        lhs_G = ((strys.(['wagetax_' sreg]) + strys.(['capitaltax_' sreg]) + strys.(['tauC_' sreg]) * strys.(['P_' sreg]) * strys.(['C_' sreg]) + strys.(['tauH_' sreg]) *  strys.(['PH_' sreg]) * strys.(['IH_' sreg]) + strys.(['PE_' sreg]) * strys.(['E_' sreg])) - (strys.rf) *  strys.(['BG_' sreg]) - strys.(['adaptationcost_' sreg]))/strys.(['P_' sreg]) - strys.(['Tr_' sreg]);
        if strpar.phiG_p > 0
            rhs_G = strys.(['G_' sreg]);
            fval_vec_G(icoreg) = 1 - rhs_G / lhs_G;
        else
            % strys.(['G_' sreg]) = lhs_G;
            strys.(['KG_' sreg]) = strys.(['G_' sreg])/strpar.deltaKG_p;
            % government expenditure
            strys.G = strys.G + strys.(['P_' sreg]) * strys.(['G_' sreg]);
        end
    end
    %% evaluate resiudals for: 
    % - HH FOC w.r.t. labour in each region and subsector
    % - Firms FOC w.r.t. intermediate goods in each region and subsector
    % - Export demand for each region and subsector

    strpar.sMaxsec = num2str(strpar.inbsectors_p);
    
    fval_vec_1 = nan(strpar.(['subend_' strpar.sMaxsec '_p'])*strpar.inbregions_p,1);
    
    fval_vec_2 = nan(strpar.(['subend_' strpar.sMaxsec '_p'])*strpar.inbregions_p,1);
    
    fval_vec_3 = nan(strpar.(['subend_' strpar.sMaxsec '_p'])*strpar.inbregions_p,1);
    
    fval_vec_4 = nan(strpar.(['subend_' strpar.sMaxsec '_p'])*strpar.inbregions_p,1);
    
    fval_vec_5 = nan(strpar.inbregions_p,1);            
    
    fval_vec_6 = nan(strpar.inbregions_p,1);            
    
    for icoreg = 1:strpar.inbregions_p
        sreg = num2str(icoreg);       
        strys.(['Xhelp_' sreg ]) = 0;
        for icosec = 1:strpar.inbsectors_p
            ssec = num2str(icosec);
            for icosubsec = strpar.(['substart_' ssec '_p']):strpar.(['subend_' ssec '_p'])
                ssubsec = num2str(icosubsec);
                temp=(strpar.(['D_X_' ssubsec '_' sreg '_p']) * exp(strexo.(['exo_X_' ssubsec '_' sreg]))) * ((strys.(['P_Q_' ssubsec '_' sreg]) + 0*strpar.(['kappaE_' ssubsec '_' sreg '_p']) * strpar.(['lEndoQ_' ssubsec '_' sreg '_p']) * strys.(['PE_' sreg]))/strys.(['P_Q_' sreg])^1)^(-strpar.etaX_p);
                strys.(['Xhelp_' sreg ]) = strys.(['Xhelp_' sreg ]) + temp;
            end
        end

        for icosec = 1:strpar.inbsectors_p
            ssec = num2str(icosec);
            for icosubsec = strpar.(['substart_' ssec '_p']):strpar.(['subend_' ssec '_p'])
                ssubsec = num2str(icosubsec);
              
                icovec = icosubsec + strpar.(['subend_' num2str(strpar.inbsectors_p) '_p']) * (icoreg-1);
                
                
                
                if strpar.(['lEndoN_'  ssubsec '_' sreg '_p']) == 1
                    lhs = (1 - strys.(['tauNH_' sreg])) * strys.(['W_' ssubsec '_' sreg]) * strys.(['LF_' sreg]) / strys.(['PoP_' sreg]) * strys.(['lambda_' sreg]);
                    rhs = strpar.(['phiL_' ssubsec '_' sreg '_p']) * strys.(['A_N_' ssubsec '_' sreg]) * (strys.(['N_' ssubsec '_' sreg]))^(strpar.sigmaL_p);
                else
                    lhs = strys.(['N_' ssubsec '_' sreg]);
                    rhs = strpar.(['phiN0_' ssubsec '_' sreg '_p']) * strpar.(['N0_' sreg '_p']) * exp(strexo.(['exo_Q_' ssubsec '_' sreg]));
                end
                fval_vec_1(icovec) = 1 - lhs./rhs;
                
                % lhs = strys.(['P_I_' ssubsec '_' sreg]) / (strys.(['P_Q_' ssubsec '_' sreg]) - strpar.(['kappaE_' ssubsec '_' sreg '_p']) * strpar.(['lEndoQ_' ssubsec '_' sreg '_p']) * strys.(['PE_' sreg]));
                lhs = strys.(['P_I_' ssubsec '_' sreg]) / strys.(['P_' ssubsec '_' sreg]);
                
                % rhs = strys.(['A_I_' ssubsec '_' sreg])^((strpar.(['etaI_' ssubsec '_p'])-1)/strpar.(['etaI_' ssubsec '_p'])) * (strpar.(['omegaQI_' ssubsec '_' sreg '_p']))^(1/strpar.(['etaI_' ssubsec '_p'])) * (strys.(['Q_I_' ssubsec '_' sreg])/strys.(['Q_' ssubsec '_' sreg]))^(-1/strpar.(['etaI_' ssubsec '_p']));
                rhs = strys.(['A_I_' ssubsec '_' sreg])^((strpar.(['etaI_' ssubsec '_p'])-1)/strpar.(['etaI_' ssubsec '_p'])) * (strpar.(['omegaQI_' ssubsec '_' sreg '_p'])/(1-strpar.(['omegaQI_' ssubsec '_' sreg '_p'])))^(1/strpar.(['etaI_' ssubsec '_p'])) * (strys.(['Q_I_' ssubsec '_' sreg])/strys.(['Y_' ssubsec '_' sreg]))^(-1/strpar.(['etaI_' ssubsec '_p']));



                fval_vec_2(icovec) = 1 - lhs./rhs;               
                
                lhs = strys.(['X_' ssubsec '_' sreg])/strys.(['X_' sreg])^1;
                
                rhs = strpar.(['D_X_' ssubsec '_' sreg '_p']) * exp(strexo.(['exo_X_' ssubsec '_' sreg])) * ((strys.(['P_Q_' ssubsec '_' sreg]) + 0*strpar.(['kappaE_' ssubsec '_' sreg '_p']) * strpar.(['lEndoQ_' ssubsec '_' sreg '_p']) * strys.(['PE_' sreg]))/strys.(['P_Q_' sreg])^1)^(-strpar.etaX_p)/strys.(['Xhelp_' sreg ])^0;
                
                fval_vec_3(icovec) = 1 - lhs/rhs;
                
                lhs = strys.(['Q_' ssubsec '_' sreg]) - strys.(['X_' ssubsec '_' sreg]);
                
                temp = 0;
                for icoregm = 1:strpar.inbregions_p
                    sregm = num2str(icoregm);
                    temp = temp  + strys.(['Q_D_' ssubsec '_' sregm '_' sreg]);                
                    
                end
                rhs = temp;
                                
                fval_vec_4(icovec) = 1 - lhs/rhs;
                
            end

        end
        if strpar.etaQ_p == 1
            lhs = strys.(['P_D_' sreg]);
            rhs = 1;
            for icosec = 1:strpar.inbsectors_p
                ssec = num2str(icosec);
                rhs = rhs*(strys.(['P_A_' ssec '_' sreg])/strpar.(['omegaQA_' ssec '_' sreg '_p']))^strpar.(['omegaQA_' ssec '_' sreg '_p']);
            end
        else
            lhs = strys.(['P_D_' sreg]);
            rhs = 0;
            for icosec = 1:strpar.inbsectors_p
                ssec = num2str(icosec);
                rhs = rhs + strpar.(['omegaQA_' ssec '_' sreg '_p']) * (strys.(['P_A_' ssec '_' sreg]))^((1-strpar.etaQ_p));
            end
            rhs = rhs^(1/(1-strpar.etaQ_p));
        end
        fval_vec_5(icoreg) = 1 - lhs/rhs;
        rhs = strys.(['sF_' sreg]);
        lhs = strys.(['Q_D_' strpar.ssubsecfossil '_' sreg])/ strys.(['Q_A_' strpar.ssecenergy '_' sreg]);
        fval_vec_6(icoreg) = 1 - lhs/rhs;
        
    end
    

    

    if strpar.lCalibration_p ==2
        fval_vec = [fval_vec_1(:); fval_vec_3(:); fval_vec_4(:); fval_vec_5(:); fval_vec_6(:); fval_vec_G(:)];
    end
    if strpar.phiG_p > 0
        fval_vec = [fval_vec_1(:); fval_vec_2(:); fval_vec_3(:); fval_vec_4(:); fval_vec_5(:); fval_vec_6(:); fval_vec_G(:)];
        
    else
        fval_vec = [fval_vec_1(:); fval_vec_2(:); fval_vec_3(:); fval_vec_4(:); fval_vec_5(:); fval_vec_6(:)];
        
    end

    if strpar.lExoNX_p == 1 
%        evaluation of the net export to gross value added ratio
        if strpar.lEndogenousY_p == 0
            fval_vec_NX = strys.NX./strys.Y - (strpar.NX0_p + strexo.exo_NX);
        else
            fval_vec_NX = strys.NX/(strpar.NX0_p * strys.Y)-1;
        end
        fval_vec = [fval_vec; fval_vec_NX];
    end

    if any(strys.lEndoQvec(:) == 0)
        fval_vec_8 = nan(sum(strys.lEndoQvec==0)*1, 1);
        icomatch = 0;
        for icosec = 1:strpar.inbsectors_p
            ssec = num2str(icosec);
            for icosubsec = strpar.(['substart_' ssec '_p']):strpar.(['subend_' ssec '_p'])
                ssubsec = num2str(icosubsec);
                for icoreg = 1:strpar.inbregions_p
                    sreg = num2str(icoreg);
                    if strpar.(['lEndoQ_' ssubsec '_' sreg '_p']) == 0
                        icomatch = icomatch + 1;
                        lhs1 = strys.(['Q_' ssubsec '_' sreg]);
                        rhs1 = strpar.(['Q0_' ssubsec '_' sreg '_p']) * exp(strexo.(['exo_Q_' ssubsec '_' sreg])); %# ok
                        fval_vec_8(icomatch) = 1-lhs1/rhs1;
                    end
                end
            end
        end
        fval_vec = [fval_vec; fval_vec_8];
    end

    if any(strys.lEndoQIvec(:))
        fval_vec_9 = nan(sum(strys.lEndoQIvec==1)*1, 1);
        icomatch = 0;
        for icosec = 1:strpar.inbsectors_p
            ssec = num2str(icosec);
            for icosubsec = strpar.(['substart_' ssec '_p']):strpar.(['subend_' ssec '_p'])
                ssubsec = num2str(icosubsec);
                for icoreg = 1:strpar.inbregions_p
                    sreg = num2str(icoreg);
                    icovec = icoreg + (icosubsec-1)*strpar.inbregions_p;
                    if strys.lEndoQIvec(icovec)
                        icomatch = icomatch + 1;
                        lhs1 = strys.(['Q_I_' ssubsec '_' sreg]) * strys.(['P_I_' ssubsec '_' sreg])/((strys.(['P_Q_' ssubsec '_' sreg])-strpar.(['kappaE_' ssubsec '_' sreg '_p'])*strys.(['PE_' sreg])) * strys.(['Q_' ssubsec '_' sreg]));
                        rhs1 = strpar.(['phiQI_' ssubsec '_' sreg '_p'])/(strpar.(['phiQI_' ssubsec '_' sreg '_p']) + strpar.(['phiY0_' ssubsec '_' sreg '_p'])) * exp(strexo.(['exo_QI_' ssubsec '_' sreg])); %# ok
                        fval_vec_9(icomatch) = 1-lhs1/rhs1;
                    end
                end
            end
        end
        fval_vec = [fval_vec; fval_vec_9];
    end


   if strpar.lEndoMig_p == 1
        fval_vec_10 = nan(strpar.inbregions_p, 1);
        denominator = 0;
        for icoreg = 1:strpar.inbregions_p
            sreg = num2str(icoreg);
            denominator = denominator + strpar.(['omegaLF0_' sreg '_p']) * exp(strexo.(['exo_LF_' sreg])) * (strys.(['W_' sreg]) / strys.W)^(strpar.etaLF_p);
        end
        
        for icoreg = 1:strpar.inbregions_p
            sreg = num2str(icoreg);
            lhs = strys.(['LF_' sreg]);
            rhs = strpar.(['omegaLF0_' sreg '_p']) * exp(strexo.(['exo_LF_' sreg])) * (strys.(['W_' sreg]) / strys.W)^(strpar.etaLF_p) / denominator * strys.LF;
            fval_vec_10(icoreg) = 1-lhs/rhs;
        end
        fval_vec = [fval_vec; fval_vec_10];
    end
    
    % find subsisdy rate to distribute respective share of emission
    % certificates
    if strexo.exo_CapTradeInternat == 1 && strpar.lEndogenousY_p == 1
        % evaluation of the emissions
        fval_vec_E = (1 + strys.E) / (1 + strpar.E0_p * exp(strexo.exo_E))-1;
        fval_vec = [fval_vec; fval_vec_E];
    else
        strys.EMIEXP = 0;
        for icoreg = 1:strpar.inbregions_p
            sreg = num2str(icoreg);
            if strexo.(['exo_CapTrade_' sreg]) == 1 && strpar.lEndogenousY_p == 1
                fval_vec_E = strys.(['E_' sreg]) / (strpar.(['E0_' sreg '_p']) * exp(strexo.(['exo_E_' sreg])))-1;
                fval_vec = [fval_vec(:); fval_vec_E];
            end
            strys.EMIEXP = strys.EMIEXP + strys.(['PE_' sreg]) * strys.(['E_' sreg]);
        end
        strys.PE = strpar.PE0_p;
    end


    for icoreg = 1:strpar.inbregions_p
        sreg = num2str(icoreg);
        if strexo.(['exo_tauSTr_' sreg]) > 0
            lhs = strys.(['Tr_' sreg]);
            rhs = strpar.(['Tr0_' sreg '_p'])  + strexo.(['exo_Tr_' sreg]) + strexo.(['exo_tauSTr_' sreg]) * strys.(['PE_' sreg]) * strys.(['E_' sreg]);
            fval_vec = [fval_vec(:); lhs/rhs-1];
        end
    end

    for icoreg = 1:strpar.inbregions_p
        sreg = num2str(icoreg);
        if strexo.(['exo_tauS_' sreg]) > 0
            lhs = strys.(['capitalexp_' sreg]) * strys.(['tauS_' sreg]);
            rhs = strexo.(['exo_tauS_' sreg]) * strys.(['PE_' sreg]) * strys.(['E_' sreg]);
            fval_vec = [fval_vec(:); lhs/rhs-1];
        end
    end
    
    if strpar.iSecHouse_p ~= 0
        for icoreg = 1:strpar.inbregions_p
            sreg = num2str(icoreg);
            if strpar.lEndogenousY_p == 0
                % house prices
                lhs = strys.(['PH_' sreg]);
                rhs = (strpar.(['gamma_' sreg '_p'])/((1 - strpar.(['gamma_' sreg '_p'])) * (1-strpar.beta_p * exp(strexo.exo_beta) * strpar.h_p))  * strpar.beta_p * exp(strexo.exo_beta) / (1 - strpar.beta_p * exp(strexo.exo_beta) * (1 - strpar.deltaH_p)) * (1-strpar.h_p)*strys.(['C_' sreg]) * strys.(['P_' sreg]) * (1 + strys.(['tauC_' sreg]))) / (strys.(['H_' sreg]) * (1 + strys.(['tauH_' sreg])));    
            else
                % housing stock
                lhs = strys.(['H_' sreg]);
                rhs = (strpar.(['gamma_' sreg '_p'])/((1 - strpar.(['gamma_' sreg '_p']))* (1-strpar.beta_p * exp(strexo.exo_beta) * strpar.h_p))  * strpar.beta_p * exp(strexo.exo_beta) / (1 - strpar.beta_p * exp(strexo.exo_beta) * (1 - strpar.deltaH_p)) * (1-strpar.h_p)*strys.(['C_' sreg]) * strys.(['P_' sreg]) * (1 + strys.(['tauC_' sreg]))) / (strys.(['PH_' sreg]) * (1 + strys.(['tauH_' sreg])));    
            end
            fval_vec = [fval_vec(:); lhs/rhs-1];
        end
    end


end
